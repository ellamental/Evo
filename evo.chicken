;;__________________________________________________________________________;;
;; evo
;; evo.chicken
;; (load "/media/DATA/code/evo/evo.chicken")
;;__________________________________________________________________________;;

(use srfi-42)

(define (choice #!rest lst)
  (define all (apply append lst))
  (list-ref all (random (length all))))
  ;(define first-choice (list-ref lst (random (length lst))))
  ;(list-ref first-choice (random (length first-choice))))



;; f = '(prototype tests funcs terms best gene-pool fitness-rules)
(define (func-closure f)
  (define prototype (car f))
  (define tests (list-ref f 1))
  (define funcs (list-ref f 2))
  (define terms (list-ref f 3))
  (define gene-pool (list-ref f 4))
  ;(define best (list-ref f 5))
  ;(define fitness-rules (list-ref f 6))
  (define num-tests (length tests))
  (define args (cdr prototype))
  (define first-test (car tests))

  
;;   (define (tag-value t)
;;     (hash-table-ref meta t))
;;   (define (set-tag tag value)
;;     (hash-table-set! meta tag value))
;;   
  
  ;;___________________________________________;;
  ;; Generating Functions
  ;;___________________________________________;;
  
  (define (random-func)
    (random-function))
  
  
  (define (get-term) (choice args terms))
  (define (get-func) (choice funcs)) ; also choose from gene-pool
  
  (define (random-function)
    (define (random-expression probability)
      (if (> (random 100) probability)
        (get-term)
        (let ((f (get-func)))
          (cons (car f)
                (list-ec (: i (length (cdr f))) (random-expression (- probability 10)))))))
    (list 'lambda args (random-expression 99)))
  
  (define (swap) #f)
    
  
  ;;___________________________________________;;
  ;; Evaluating and Testing Functions
  ;;___________________________________________;;
 
  
  (define (eval-func func args)
    ;(print func #\newline args)
    (condition-case (apply (eval func) args) [(exn) (void)]))
  
  (define (test f test-args test-result)
    (if (equal? (eval-func f test-args) test-result) #t #f))

  (define (eval-times count)
    (define test-args (caar tests))
    (define test-result (cdar tests))
    (define (eval-loop count)
      (define f (random-func))
      (if (= 0 count)
        (print "Finished")
        (begin
          (if (test f test-args test-result) (store f))
          (eval-loop (- count 1)))))
    (eval-loop count))
    

  
  ;;___________________________________________;;
  ;; Storing and Retrieving Functions
  ;;___________________________________________;;

  (define (fitness f)
    ;run all tests determining for each one:
      ;fitness
      ;runtime
      ;memory
    ;average the runtime, memory-usage and fitness
    ;calculate the size of the func tree
    ;return (fitness, runtime, memory, size)
  ;;For now we'll just return fitness
    (define correct (length (filter (lambda (t) (test f (car t) (cdr t))) tests)))
    (/ correct num-tests))
  
  
  ;; Automatically write all funcs that pass one test to gene-pool
  ;; if full then must pass two tests to write over function
  (define (store f)
    (define fit (fitness f))
    (if (> fit .3) 
      (set! gene-pool (cons (cons f fit) gene-pool))))

  (define (write-to-disk)
    "Write the closure to disk or database")
  (define (read-from-disk)
    "Read closure from disk - This involves calling (func-closure name)")

  
  ;;___________________________________________;;
  ;; Dispatch
  ;;___________________________________________;;

  (define (dispatch message . arguments)
    (cond ((equal? message 'prototype) prototype)
          ((equal? message 'tests) tests)
          ((equal? message 'funcs) funcs)
          ((equal? message 'terms) terms)
          ((equal? message 'gene-pool) gene-pool)
          ((equal? message 'random-func) (random-func))
          ((equal? message 'eval-func) (apply eval-func arguments))
          ((equal? message 'test) (apply test arguments))
          ((equal? message 'eval-times) (apply eval-times arguments))
          ((equal? message 'fitness) (apply fitness arguments))
          ((equal? message 'get-func) (get-func))))
  dispatch
)


;; Ideal def-module; for now must supply tags for all meta-data (tag name data)
;; 
;; (def-module name
;;   (function-set terminal-set)
;;   
;;   (def (func-name arg arg-2)
;;     ("docstring - if the first elem of list is a string it is a docstring
;;       Other attributes are optional, defaults are used if not supplied.
;;       This list should be accessed as an a-list, even (docstring string)"
;;       (tests '(((func-name 3 4) 7)  ;; (name args) test or 
;;                ((3 4) 7)))          ;; (args) test are both appropriate
;;       (funcs (+ - / *)))            ;; add or remove functions from function-set
;;     ;; A working prototype does not have to be supplied.
;;     ;; If it is it becomes the function's (best )
;;     ;; If no tests are supplied it becomes the first test.
;;     (+ arg arg-2)))

(define-syntax tag
  (syntax-rules ()
    ((tag name data)
      (cons 'name data))
    ((tag name data ...)
      (cons 'name '(data ...)))))

(define-syntax def-module
  (syntax-rules ()
    ((def-module (funcs terms) defs ...)
      (let ((function-set 'funcs)
            (terminal-set 'terms))
           (list defs ...)))))

(define-syntax def
  (syntax-rules ()
    ((def proto meta ...)
      (list (tag prototype 'proto)
            (tag funcs function-set)
            (tag terms terminal-set)
            meta ...))))

 

(define a 
(def-module
  (((+ num num) (- num num) (< num num) (> num num) (if t c a))
   (#t #f 0 1))
  
  (def (med x y z)
    (tag doc
      "Docstring")
    (tag tests
      ((5 3 7) . 5)
      ((9 7 3) . 7)
      ((9 3 6) . 6)
      ((3 7 5) . 5))
    (tag best
      '(lambda (x y z)
        (if (> x y)
            (if (> x z)
                (if (> y z) y z)
                x)
            (if (> x z)
                x
                (if (> y z) z y))))))
  
  (def (plus x y)
    (tag doc "docstring")
    (tag tests 
      ((3 4) . 7)
      ((7 2) . 9)))
  )
)  

;; func storage model
;;_____________________;;

;; name         cons
;; 
;; prototype    (cons any lst)
;; 
;; tests        (((cons 1 '()) '(1)) ((cons 1 '(2 3)) '(1 2 3)))
;; 
;; funcs        ( (+ num num)  (- num num)
;;                (* num num)  (= num num)
;;                (car lst)    (cdr lst)
;;                (if t c a))
;; 
;; terms        (#t #f pi)  ;; or function with no args
;; 
;; best-func    (lambda (any:o lst:l) (cons any:o lst:l))
;; 
;; gene-pool    (List of programs that have passed one or more tests.)
;;
;; fitness-rules = Traits most sought in this function (space, speed...)

;; name
;; The name is the symbol that will be registered by this function upon loading
;; (note that the name will most assuredly be prefixed with a module name as well).
;; The name is slightly redundant as it is also present within the prototype.
;; 
;; prototype
;; The prototype of a function is a mockup of how you would call the function.
;; The prototype's purpose is to convey information about the arguments to the 
;; function.  It can signal arbitrary arguments (+ num:1 ...) as well as give 
;; type information to the function building routines.  
;; 
;; tests
;; The test suite determines the fitness of any generated function.  Newly
;; generated functions are tested against the suite to determine admittance to 
;; the gene-pool.  Tests are stored as (args answer) pairs and will likely be
;; generated by a testing function that allows more readable format such as 
;; (test 
;;   (< 3 4) >>> #t
;;   (< 4 3) >>> #f)
;; 
;; funcs
;; The function set available when generating new functions.  Each function in
;; the function set is stored as a prototype and as such offers the generator
;; a way of type checking the arguments.
;; 
;; terms
;; The terminal set available when generating new functions.  Terminals can 
;; be constants such as #t, '() and pi, or they can be functions which take 
;; no arguments (as a 0-arity func can not grow the tree).
;; 
;; best-func
;; The best, fully test-compliant, function in the gene pool.  If there is no
;; fully test-compliant function in the gene pool best-func will return some
;; sort of "not implemented".  This is the function that will be called when
;; used in other code and can be pre-compiled.
;; 
;; gene-pool
;; The gene pool is where correct functions are saved.  It is from this pool 
;; that the functions for manipulating genes get their genes.



;; Breeding
;; 
;; Random:  A random node is generated.
;; Interfunction:  A function is chosen from the gene pool and nodes of its tree
;;   are swapped and mutated.
;; Crossover:  Two functions are chosen and random nodes are swapped.
;; Assimilation:  A function is chosen and a random node is swapped with a 
;;   function from the gene-pool.


