;;__________________________________________________________________________;;
;; evo
;; evo.chicken
;;__________________________________________________________________________;;

(use srfi-42)

(define (choice #!rest lst)
  (define first-choice (list-ref lst (random (length lst))))
  (list-ref first-choice (random (length first-choice))))

(define (random-func args funcs terminals)
  
  (define (get-term)
    (choice args terminals))
  (define (get-func)
    (choice funcs))

  (define (random-expression)
    (define (get-expression)
      (let ((f (get-func)))
        (cons (car f)
              (list-ec (: i (length (cdr f))) (random-expression)))))
  
    (if (> 6 (random 10))
      (get-term)
      (get-expression)))

  
  (list 'lambda args (random-expression)))


(define (test-one)
  ;; (define func "A storage object that contains all the info about a func
  ;;
  (define prototype '(> num:1 num:2 num:3))  ;; (func-get prototype)
  (define tests '(((3 4 5) . 4) 
                  ((7 10 5) . 7)))
  (define funcs '( (< num num)  (> num num)
                   (= num num)  (car lst)
                   (cdr lst)    (if t c a)))
  (define terminals '(#t #f))
  (define args (cdr prototype))
  
  (define (eval-func func args)
    (condition-case (apply (eval func) args) [(exn) (void)]))

  (define (eval-once func test)
    (if (equal? (eval-func func (car test)) (cdr test)) #t #f))
  
  (define (eval-until #!optional (test (car tests)) (counter 0))
    (define func (random-func args funcs terminals))
    (if (eval-once func test)
      ;        (print #\newline "Passed 1" #\newline func #\newline counter #\newline)
      (if (eval-once func (cadr tests))
        (print #\newline "Successful!" #\newline func #\newline counter)
        (eval-until test (+ counter 1)))
      (eval-until test (+ counter 1))))
  
  (eval-until)
  
  )

(test-one)


  
;; func storage model
;;_____________________;;

;; name         cons
;; 
;; prototype    (cons any:o lst:l)
;; 
;; tests        (((cons 1 '()) '(1)) ((cons 1 '(2 3)) '(1 2 3)))
;; 
;; funcs        ( (+ num num)  (- num num)
;;                (* num num)  (= num num)
;;                (car lst)    (cdr lst)
;;                (if t c a))
;; 
;; terms        (#t #f pi)  ;; or function with no args
;; 
;; best-func    (lambda (any:o lst:l) (cons any:o lst:l))
;; 
;; gene-pool    (List of programs that have passed one or more tests.)
;;
;; fitness-rules = Traits most sought in this function (space, speed...)

;; name
;; The name is the symbol that will be registered by this function upon loading
;; (note that the name will most assuredly be prefixed with a module name as well).
;; The name is slightly redundant as it is also present within the prototype.
;; 
;; prototype
;; The prototype of a function is a mockup of how you would call the function.
;; The prototype's purpose is to convey information about the arguments to the 
;; function.  It can signal arbitrary arguments (+ num:1 ...) as well as give 
;; type information to the function building routines.  
;; 
;; tests
;; The test suite determines the fitness of any generated function.  Newly
;; generated functions are tested against the suite to determine admittance to 
;; the gene-pool.  Tests are stored as (args answer) pairs and will likely be
;; generated by a testing function that allows more readable format such as 
;; (test 
;;   (< 3 4) >>> #t
;;   (< 4 3) >>> #f)
;; 
;; funcs
;; The function set available when generating new functions.  Each function in
;; the function set is stored as a prototype and as such offers the generator
;; a way of type checking the arguments.
;; 
;; terms
;; The terminal set available when generating new functions.  Terminals can 
;; be constants such as #t, '() and pi, or they can be functions which take 
;; no arguments (as a 0-arity func can not grow the tree).
;; 
;; best-func
;; The best, fully test-compliant, function in the gene pool.  If there is no
;; fully test-compliant function in the gene pool best-func will return some
;; sort of "not implemented".  This is the function that will be called when
;; used in other code and can be pre-compiled.
;; 
;; gene-pool
;; The gene pool is where correct functions are saved.  It is from this pool 
;; that the functions for manipulating genes get their genes.











