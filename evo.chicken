;; (load "evo.chicken")
;; 
;; Evolutionary Search
;; 
;; TODO:
;; - Write 'load-function-set to load prototypes from all modules listed
;; - Right now each function carries it's own set of "funcs".  This is redundant
;;   A module should carry a list of modules to load into the "funcs".  When the
;;   "funcs" list is created modules should be loaded from the parent module and
;;   any additional definitions in the function.
;; - Provide a 'save' button in the function GUI.  This will require the ability
;;   to read from each text box, not currently possible.  A reference to each
;;   box will have to be kept.  I don't know whether to create objects out of 
;;   the frames, each with get and set methods or if I should do it globally.
;; - Provide a 'new' button in the function GUI.
;; - Decide if the fitness of a node should be stored with it in gene pool.
;;     Pros: Don't have to retest; can provide pool avg fitness
;;     Cons: Extra storage, more complicated design
;; - Split off GUI into seperate file.
;; - Provide a mechanism for specifying the type a function returns and use
;;   that type when generating new nodes
;; - Make arbitrary length gene-pools
;;
;; - Add a (use-evo 'math) to allow users to use modules in outside code
;; - Make a converter that reads regular Scheme code and builds up evo modules.
;;___________________________________________________________________________;;

(require-extension tk)        ;; GUI
(require-extension posix)     ;; GUI - Building a list of modules
(require-extension srfi-1)
(require-extension srfi-42)

(define (make-module name)
  (define filename (if (string? name) (conc "project/" name)
                                      (conc "project/" (symbol->string name))))

  (define (load-module)
    (define f (open-input-file filename))
    (define mod (read f))
    (close-input-port f)
    mod)

  (define (store-module)
    (define f (open-output-file filename))
    (write module f)
    (close-output-port f))
  
  (define module (load-module))
  
  (define (add-func definition)
    (set! module (cons definition module)))

  (define (get-func func-name)
    (assoc func-name module))

  (define (list-of-names)
    (map (lambda (x) (car x)) module))
  
  (define (prototypes) "list of function prototypes to use in testing")
  
  (define (eval-times count)
    (map (lambda (f) ((make-func f) 'eval-times count)) module))
  
  (define (dispatch m . arguments)
    (cond ((equal? m 'name) name)
          ((equal? m 'module) module)
          ((equal? m 'list-of-names) (list-of-names))
          ((equal? m 'store-module) (store-module))
          ((equal? m 'add-func) (apply add-func arguments))
          ((equal? m 'get-func) (apply get-func arguments))
          ((equal? m 'eval-times) (apply eval-times arguments))
  ))
  dispatch
)



(define (choice alist #!optional (type 'any))
  (define (random-choice l)
    (list-ref l (random (length l))))
  (if (equal? type 'any)
      (random-choice (cdr (random-choice alist)))
      (random-choice (cdr (assoc type alist)))))



(define (make-func meta-alist)
  (define name (car meta-alist))
  (define meta (cdr meta-alist))

  (define (set-tag tag value)
    (if (assoc tag meta)
        (set-cdr! (assoc tag meta) value)
        (set! meta (cons (cons tag value) meta))))
  
  (define (append-tag tag value)
    (define t (assoc tag meta))
    (if t
        (set-cdr! t (cons value (cdr t)))
        (set! meta (cons (cons tag value) meta))))
  
  (define (tag-value tag)
    (cdr (assoc tag meta)))

  (define (load-function-set)
    ;; load prototypes from each module and sort by type
    '((num (+ num num) (- num num)) 
      (bool (< num num) (> num num) (if any any any))))
    
  ;; TODO: create funcs and terms only when required
  (define funcs (load-function-set))
  (define terms '((num 0 1) (bool #t #f)))

  ;; TODO: arg-types should be deleted and replaced by something more elegant
  (define args (map cdr (tag-value 'proto)))
  (define arg-types (list (cons 'num args)))

  (define first-test-args (caar (tag-value 'tests)))
  (define first-test-result (cdar (tag-value 'tests)))
  (define number-of-tests (length (tag-value 'tests)))
  (define gene-pool (tag-value 'gene-pool))

  
  (define (choose-func #!optional (type 'any))
    (choice funcs type))
  
  (define (choose-term #!optional (type 'any))
    (if (> (random 100) 30)
        (choice arg-types type)
        (choice terms type)))
  
  
  (define (random-node #!optional (type 'any) (func-prob 70))
    (if (> (random 100) func-prob)
      (choose-term type)
      (let ((f (choose-func type)))
        (cons (car f)
              (map (lambda (t) (random-node t (- func-prob 10))) (cdr f))))))
    
  
  (define (eval-node node arguments)
    (condition-case (apply (eval (list 'lambda args node)) arguments)
      [(exn) (print 'error)]))

  
  (define (eval-times count)
    (if (= count 0)
        (print "Finished")
        (begin 
          (quick-test (random-node))
          (eval-times (- count 1)))))
  
  
  (define (quick-test node)
    (if (equal? (condition-case 
                  (apply (eval (list 'lambda args node)) first-test-args)
                  [(exn) (void)])
                first-test-result)
        (submit-to-gene-pool node (fitness node))
        #f))
  
  
  (define (fitness node)
    (define node-proc (eval (list 'lambda args node)))
    ;; later measure speed/space/size/etc
    (/ (length 
         (filter (lambda (test) 
                   (equal? (condition-case (apply node-proc (car test)) 
                                           [(exn) (void)])
                           (cdr test)))
                 (tag-value 'tests)))
       number-of-tests))
  
  
  (define (submit-to-gene-pool node fitness-results)
    (define (tournament-selection pool)
      (define cell-number (random (length (cdr pool))))
      (define cell (drop (cdr pool) cell-number))
      (define incumbant (car cell))
      (define i-results (fitness incumbant))
      (if (> fitness-results i-results)
        (begin
          (set-car! cell node)  
          (print "Battle won!  Setting new node." #\newline
                  "Old fitness: " i-results #\newline
                  "New fitness: " fitness-results #\newline
                  "Old node: " incumbant #\newline
                  "New node:  " node #\newline
                  "Pool node: " (list-ref (cdr pool) cell-number)))
        (print "Battle lost!")))

    (define (submit-for-storage pool)
      (if (> (length (cdr pool)) 100)
          (tournament-selection pool)
          (set-cdr! pool (cons node (cdr pool)))))
    
    (define (submit-to-pools pools)
      (if (null? pools)
          #f
          (if (> fitness-results (caar pools))
              (submit-for-storage (car pools))
              (submit-to-pools (cdr pools)))))
    
    (submit-to-pools gene-pool))
  
  
  (define (dispatch m . arguments)
    (cond ((equal? m 'name) name)
          ((equal? m 'meta) meta)
          ((equal? m 'set-tag) (apply set-tag arguments))
          ((equal? m 'append-tag) (apply append-tag arguments))
          ((equal? m 'tag-value) (apply tag-value arguments))
          ((equal? m 'funcs) funcs)
          ((equal? m 'eval-times) (apply eval-times arguments))
          ((equal? m 'random-node) (random-node))
          ((equal? m 'gene-pool) gene-pool)
  ))
  dispatch
)



;; (load "load.chicken")

(define (database-browser) 
  (define mod #f)
  (define func #f)
  (define current-frame #f)
  (define font-type "Helvetica 16")

  (start-tk)
  
  (tk 'configure #:width 640)
  (tk 'configure #:height 480)
  (tk/wm 'minsize tk 640 480)
  
  (define main-menu (tk 'create-widget 'menu))
  (define module-menu (main-menu 'create-widget 'menu))
  (define function-menu (main-menu 'create-widget 'menu))

  (tk 'configure #:menu main-menu)

  (main-menu 'add 'cascade #:label 'Modules #:menu module-menu)
  (main-menu 'add 'cascade #:label 'Functions #:menu function-menu)

  
  (define (set-module name)
    (set! mod (make-module name))
    (function-menu 'delete 0 'end)
    (populate-function-menu)
    (draw-module-window))

  
  (define (set-function name)
    (set! func (make-func (mod 'get-func name)))
    (draw-func-window))

  
  (define (populate-function-menu)
    (map (lambda (name)
          (function-menu 'add 'command #:label name
            #:command (lambda () (set-function name))))
         (mod 'list-of-names)))

  
  (define (populate-module-menu)
    (map (lambda (name)
          (module-menu 'add 'command #:label name
            #:command (lambda () (set-module name))))
        (directory "project/")))
          

  (define (reset-current-frame)
    (tk/destroy current-frame)
    (set! current-frame (tk 'create-widget 'frame #:width 640 #:height 480)))


  (define (make-entry-table parent #!rest data)
    (define frame (parent 'create-widget 'labelframe #:text "Function Prototype"))
    (define (make-row label default row-number)
      (define lab (frame 'create-widget 'label #:text label #:font font-type))
      (define ent (frame 'create-widget 'entry #:font font-type))
      (ent 'insert 0 default)
      (tk/grid lab #:row row-number #:column 0)
      (tk/grid ent #:row row-number #:column 1)
      (cons lab ent))
    (define (make-table data-list result-list row-num)
      (if (null? data-list)
          result-list
          (cons (make-row (car data-list) (cadr data-list) row-num)
                (make-table (cddr data-list) result-list (+ row-num 1)))))
    (define children (make-table data '() 0))
    frame  ;; by returning only the frame we have no way of accessing the entry boxes
    )
  
  (define (make-prototype-area parent)
    (define frame (parent 'create-widget 'labelframe #:text "Function Prototype"))
    (define name-lab (frame 'create-widget 'label #:text "Name: " #:font font-type))
    (define name-ent (frame 'create-widget 'entry #:font font-type))
    (name-ent 'insert 0 (func 'name))
    (tk/grid name-lab #:row 0 #:column 0)
    (tk/grid name-ent #:row 0 #:column 1)
    (define proto-lab (frame 'create-widget 'label #:text "Prototype: " #:font font-type))
    (define proto-ent (frame 'create-widget 'entry #:font font-type))
    (proto-ent 'insert 0 (func 'tag-value 'proto))
    (tk/grid proto-lab #:row 1 #:column 0)
    (tk/grid proto-ent #:row 1 #:column 1)
  
    (define (get-values)
      (list (cons 'name (name-ent 'get))
            (cons 'proto (proto-ent 'get))))
    ;; comes out as -> ((name . plus) (proto num.x num.y)) obviously an error
    
    (define (dispatch m . arguments)
      (cond ((equal? m 'frame) frame)
            ((equal? m 'values) (get-values))
        ))
    dispatch)

  
    
    
  (define (make-text-area parent label data height)
    (define frame (parent 'create-widget 'labelframe #:text label #:font font-type))
    (define text (frame 'create-widget 'text #:height height #:width 61 #:font font-type))
    (text 'insert 'end data)
    (tk/grid text)
    frame)
  
  
  (define (draw-module-window)
    (reset-current-frame)
    (define prototype-frame (make-entry-table current-frame 
      "Name: "  (mod 'name)
      "Funcs: " (mod 'list-of-names)))
    (tk/pack prototype-frame)
    (tk/pack current-frame))
  

  (define (draw-func-window)
    (reset-current-frame)
    (define prototype-frame (make-prototype-area current-frame))
    (tk/grid (prototype-frame 'frame) #:row 0 #:column 0 #:rowspan 3)
    (print (prototype-frame 'values))
    
    (define doc (make-text-area current-frame "Docstring" (func 'tag-value 'doc) 2))
    (tk/grid doc #:row 0 #:column 1)
    
    (define modules (make-text-area current-frame "Modules Available When Testing" (func 'tag-value 'modules) 2))
    (tk/grid modules #:row 1 #:column 1)
    
    (define tests (make-text-area current-frame "Tests" (func 'tag-value 'tests) 5))
    (tk/grid tests #:row 3 #:column 0)
    
    (define pool (make-text-area current-frame "Gene Pool" (func 'tag-value 'gene-pool) 5))
    (tk/grid pool #:row 4 #:column 0)
    
    (define scratch (make-text-area current-frame "Scratch Pad" "(lambda ()" 12))
    (tk/grid scratch #:row 3 #:column 1 #:rowspan 2)
    
    ;(make-text-area current-frame "Docstring" (func 'tag-value 'doc))
    (tk/pack current-frame))

  (populate-module-menu)

  (tk/console)
  (event-loop)
)




(define m (make-module 'math))
(time (m 'eval-times 1000))

(define f (make-func (m 'get-func 'plus)))
;(time (f 'eval-times 1000))
;(length (car (f 'gene-pool)))

;(database-browser) 
