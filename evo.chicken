;; (load "evo.chicken")
;; 
;; Evolutionary Search
;; 
;; TODO:
;; GUI
;; - Split off GUI into seperate file.
;; - GUI: Saving a function creates an extra '\n at the end of the docstring
;;   every time it is saved.  This should be fixed.
;; - Add a 'create module' button in GUI
;; 
;; Module
;; - Write infinate loop to test modules
;; 
;; Function
;; - Make arbitrary length gene-pools
;; 
;; Data Storage
;; - Right now each function carries it's own set of "funcs".  This is redundant
;;   A module should carry a list of modules to load into the "funcs".  When the
;;   "funcs" list is created modules should be loaded from the parent module and
;;   any additional definitions in the function.
;; - Decide if the fitness of a node should be stored with it in gene pool.
;;     Pros: Don't have to retest; can provide pool avg fitness
;;     Cons: Extra storage, more complicated design
;; 
;; General
;; - A function should not have to be well-formed everything should work on 
;;   any function even if there are only one or two attributes defined.  For
;;   example: A function with only name, prototype and tests should still
;;   work, instead of crashing the GUI/crashing testing/etc
;;
;; Later
;; - Add a (use-evo 'math) to allow users to use modules in outside code
;; - Make a converter that reads regular Scheme code and builds up evo modules.
;;___________________________________________________________________________;;

(require-extension tk)        ;; GUI
(require-extension posix)     ;; GUI - Building a list of modules
(require-extension srfi-1)
(require-extension srfi-42)

(define (make-module name)
  (define filename (if (string? name) (conc "project/" name)
                                      (conc "project/" (symbol->string name))))

  (define (load-module)
    (define f (open-input-file filename))
    (define mod (read f))
    (close-input-port f)
    mod)

  (define (store-module)
    (define f (open-output-file filename))
    (write module f)
    (close-output-port f))
  
  (define module (load-module))
  
  (define (add-func definition)
    (set! module (cons definition module)))

  (define (get-func func-name)
    (assoc func-name module))

  (define (list-of-names)
    (map (lambda (x) (car x)) module))
  
  (define (prototypes)
    (map (lambda (f) (cons (cdr (assoc 'type (cdr f)))
                           (cons (cdr (assoc 'best (cdr f))) 
                                 (cdr (assoc 'proto (cdr f))))))
         module))
  
  (define (eval-times count)
    (map (lambda (f) ((make-func f) 'eval-times count)) module))
  
  (define (dispatch m . arguments)
    (cond ((equal? m 'name) name)
          ((equal? m 'module) module)
          ((equal? m 'list-of-names) (list-of-names))
          ((equal? m 'store-module) (store-module))
          ((equal? m 'add-func) (apply add-func arguments))
          ((equal? m 'get-func) (apply get-func arguments))
          ((equal? m 'eval-times) (apply eval-times arguments))
          ((equal? m 'prototypes) (prototypes))
  ))
  dispatch
)



(define (choice alist #!optional (type 'any))
  (define (random-choice l)
    (list-ref l (random (length l))))
  (if (equal? type 'any)
      (random-choice (cdr (random-choice alist)))
      (random-choice (cdr (assoc type alist)))))



(define (make-func meta-alist)
  (define name (car meta-alist))
  (define meta (cdr meta-alist))

  (define (set-tag tag value)
    (if (assoc tag meta)
        (set-cdr! (assoc tag meta) value)
        (set! meta (cons (cons tag value) meta))))
  
  (define (append-tag tag value)
    (define t (assoc tag meta))
    (if t
        (set-cdr! t (cons value (cdr t)))
        (set! meta (cons (cons tag value) meta))))
  
  (define (tag-value tag)
    (cdr (assoc tag meta)))

  ;; Split an alist ((type . data) ...) into ((type data data ...) (type ...))
  (define (sort-types types-list)
    (define types (hash-table-keys (alist->hash-table types-list)))
    (map (lambda (type)
           (cons type (filter-map (lambda (t) (and (equal? (car t) type) (cdr t)))
                                  types-list)))
         types))

  (define (load-function-set)
    (sort-types (apply append (map (lambda (m) (let ((mod (make-module m)))
                                                 (mod 'prototypes)))
                                   (tag-value 'modules)))))

  ;; TODO: create funcs and terms only when required
  (define funcs (load-function-set))
  (define terms '((num 0 1) (bool #t #f)))

  
  (define arg-types (sort-types (tag-value 'proto)))
  (define args (map cdr (tag-value 'proto)))

  (define first-test-args (caar (tag-value 'tests)))
  (define first-test-result (cdar (tag-value 'tests)))
  (define number-of-tests (length (tag-value 'tests)))
  (define gene-pool (tag-value 'gene-pool))

  
  (define (choose-func #!optional (type 'any))
    (choice funcs type))
  
  (define (choose-term #!optional (type 'any))
    (if (> (random 100) 30)
        (choice arg-types type)
        (choice terms type)))
  
  
  (define (random-node #!optional (type 'any) (func-prob 70))
    (if (> (random 100) func-prob)
      (choose-term type)
      (let ((f (choose-func type)))
        (cons (car f)
              (map (lambda (a) (random-node (car a) (- func-prob 10))) (cdr f))))))
    
  
  ;; not used
  (define (eval-node node arguments)
    (condition-case (apply (eval (list 'lambda args node)) arguments)
      [(exn) (print 'error)]))

  
  (define (eval-times count)
    (if (= count 0)
        (print "Finished")
        (begin 
          (quick-test (random-node))
          (eval-times (- count 1)))))
  
  
  (define (quick-test node)
    (if (equal? (condition-case 
                  (apply (eval (list 'lambda args node)) first-test-args)
                  [(exn) (void)])
                first-test-result)
        (submit-to-gene-pool node (fitness node))
        #f))
  
  
  (define (fitness node)
    (define node-proc (eval (list 'lambda args node)))
    ;; later measure speed/space/size/etc
    (/ (length 
         (filter (lambda (test) 
                   (equal? (condition-case (apply node-proc (car test)) 
                                           [(exn) (void)])
                           (cdr test)))
                 (tag-value 'tests)))
       number-of-tests))
  
  
  (define (submit-to-gene-pool node fitness-results)
    (define (tournament-selection pool)
      (define cell-number (random (length (cdr pool))))
      (define cell (drop (cdr pool) cell-number))
      (define incumbant (car cell))
      (define i-results (fitness incumbant))
      (if (> fitness-results i-results)
        (begin
          (set-car! cell node)  
          (print "Battle won!  Setting new node." #\newline
                  "Old fitness: " i-results #\newline
                  "New fitness: " fitness-results #\newline
                  "Old node: " incumbant #\newline
                  "New node:  " node #\newline
                  "Pool node: " (list-ref (cdr pool) cell-number)))
        (print "Battle lost!")))

    (define (submit-for-storage pool)
      (if (> (length (cdr pool)) 100)
          (tournament-selection pool)
          (set-cdr! pool (cons node (cdr pool)))))
    
    (define (submit-to-pools pools)
      (if (null? pools)
          #f
          (if (> fitness-results (caar pools))
              (submit-for-storage (car pools))
              (submit-to-pools (cdr pools)))))
    
    (submit-to-pools gene-pool))
  
  
  (define (dispatch m . arguments)
    (cond ((equal? m 'name) name)
          ((equal? m 'meta) meta)
          ((equal? m 'set-tag) (apply set-tag arguments))
          ((equal? m 'append-tag) (apply append-tag arguments))
          ((equal? m 'tag-value) (apply tag-value arguments))
          ((equal? m 'funcs) funcs)
          ((equal? m 'eval-times) (apply eval-times arguments))
          ((equal? m 'random-node) (random-node))
          ((equal? m 'gene-pool) gene-pool)
          ((equal? m 'arg-types) arg-types)
          ((equal? m 'sort-types) (apply sort-types arguments))
  ))
  dispatch
)



;; (load "load.chicken")
;; database-browser
(define (db) 
  (define mod #f)
  (define func #f)
  (define current-frame #f)
  (define font-type "Helvetica 16")

  (start-tk)
  
  (tk 'configure #:width 640)
  (tk 'configure #:height 480)
  (tk/wm 'minsize tk 640 480)
  
  (define main-menu (tk 'create-widget 'menu))
  (define module-menu (main-menu 'create-widget 'menu))
  (define function-menu (main-menu 'create-widget 'menu))

  (tk 'configure #:menu main-menu)

  (main-menu 'add 'cascade #:label 'Modules #:menu module-menu)
  (main-menu 'add 'cascade #:label 'Functions #:menu function-menu)

  
  (define (set-module name)
    (set! mod (make-module name))
    (function-menu 'delete 0 'end)
    (populate-function-menu)
    (draw-module-window))

  
  (define (set-function name)
    (set! func (make-func (mod 'get-func name)))
    (draw-func-window))

  
  (define (populate-function-menu)
    (map (lambda (name)
          (function-menu 'add 'command #:label name
            #:command (lambda () (set-function name))))
         (mod 'list-of-names)))

  
  (define (populate-module-menu)
    (map (lambda (name)
          (module-menu 'add 'command #:label name
            #:command (lambda () (set-module name))))
        (directory "project/")))
          

  (define (reset-current-frame)
    (tk/destroy current-frame)
    (set! current-frame (tk 'create-widget 'frame #:width 640 #:height 480)))


  (define (make-entry parent name label default)
    (define frame (parent 'create-widget 'labelframe #:text label #:font font-type))
    (define ent (frame 'create-widget 'entry #:font font-type))
    (ent 'insert 'end default)
    (tk/grid ent)
    
    (define (dispatch m . arguments)
      (cond ((equal? m 'frame) frame)
            ((equal? m 'text) (ent 'get))
        ))
    dispatch)
  
  (define (make-text parent name label default height)
    (define frame (parent 'create-widget 'labelframe #:text label #:font font-type))
    (define ent (frame 'create-widget 'text #:font font-type #:height height #:width 50))
    (ent 'insert 'end default)
    (tk/grid ent)
    
    (define (dispatch m . arguments)
      (cond ((equal? m 'frame) frame)
            ((equal? m 'text) (ent 'get 1.0 'end))
        ))
    dispatch)

  
  
  (define (draw-module-window)
    (reset-current-frame)
    (define name (make-entry current-frame 'name "Name" (mod 'name)))
    (tk/grid (name 'frame) #:row 0)
    
    (define funcs (make-entry current-frame 'funcs "Functions" (mod 'list-of-names)))
    (tk/grid (funcs 'frame) #:row 1)
    
    (tk/pack current-frame))
  

  (define (draw-func-window)
    (reset-current-frame)
    (define name (make-entry current-frame 'name "Name" (func 'name))) ;;(make-prototype-area current-frame))
    (tk/grid (name 'frame) #:row 0 #:column 0)
    
    (define type (make-entry current-frame 'type "Return Type" (func 'tag-value 'type)))
    (tk/grid (type 'frame) #:row 1 #:column 0)
    
    (define proto (make-entry current-frame 'proto "Prototype" (string-join (map ->string (func 'tag-value 'proto)) " ")))
    (tk/grid (proto 'frame) #:row 2 #:column 0)
            
    (define doc (make-text current-frame 'doc "Docstring" (func 'tag-value 'doc) 2))
    (tk/grid (doc 'frame) #:row 0 #:column 1)
    
    (define modules (make-text current-frame 'modules "Modules Available When Testing" (func 'tag-value 'modules) 2))
    (tk/grid (modules 'frame) #:row 1 #:column 1)
    
    (define tests (make-text current-frame 'tests "Tests" (string-join (map ->string (func 'tag-value 'tests)) "\n") 5))
    (tk/grid (tests 'frame) #:row 3 #:column 0)
    
    (define pool (make-text current-frame 'gene-pool "Gene Pool" (func 'tag-value 'gene-pool) 5))
    (tk/grid (pool 'frame) #:row 4 #:column 0)
    
    (define scratch (make-text current-frame 'scratch "Scratch Pad" (func 'tag-value 'best) 12))
    (tk/grid (scratch 'frame) #:row 3 #:column 1 #:rowspan 2)
        
    (define save (current-frame 'create-widget 'button #:text "Save"
                   #:command (lambda ()
                               (if (equal? (string->symbol (name 'text)) (func 'name))
                                   (begin
                                     (func 'set-tag 'type (string->symbol (type 'text)))
                                     (func 'set-tag 'proto (read (open-input-string (conc "(" (proto 'text) ")"))))
                                     (func 'set-tag 'doc (doc 'text))
                                     (func 'set-tag 'modules (read (open-input-string (conc "(" (modules 'text) ")"))))
                                     (func 'set-tag 'tests (read (open-input-string (conc "(" (tests 'text) ")"))))
                                     (mod 'store-module))
                                   (begin
                                     (mod 'add-func 
                                       (list (string->symbol (name 'text))
                                             (cons 'type (string->symbol (type 'text)))
                                             (cons 'proto (read (open-input-string (conc "(" (proto 'text) ")"))))
                                             (cons 'doc (doc 'text))
                                             (cons 'modules (read (open-input-string (conc "(" (modules 'text) ")"))))
                                             (cons 'tests (read (open-input-string (conc "(" (tests 'text) ")"))))
                                             (cons 'gene-pool (read (open-input-string (conc "(" (pool 'text) ")"))))))
                                     (mod 'store-module))))))
    (tk/grid save #:row 5 #:column 1)
    
    (tk/pack current-frame))

  (populate-module-menu)

  (tk/console)
  (event-loop)
)



(define m (make-module 'math))
(time (m 'eval-times 1000))

(define f (make-func (m 'get-func 'plus)))
;(time (f 'eval-times 1000))
;(length (car (f 'gene-pool)))

;(db)
